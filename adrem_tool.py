# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ADREMTool
                                 A QGIS plugin
 No desrciption yet
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-05
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Louis- FULL 2021
        email                : louis.andrianaivo@polito.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QUrl
from qgis.PyQt.QtGui import QIcon, QDesktopServices
from qgis.PyQt.QtWidgets import QAction, QFileDialog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .adrem_tool_dialog import ADREMToolDialog
import os.path
######################################################
from pathlib import Path
import os
import sys

from qgis.core import (
    QgsVectorLayer, 
    QgsProject, 
    Qgis, 
    QgsVectorDataProvider, 
    QgsField,
    QgsPointXY,
    QgsWkbTypes,
    QgsFillSymbol,
    QgsCategorizedSymbolRenderer,
    QgsRendererCategory)
import os, sys
from qgis.utils import iface

import processing
from PyQt5.QtCore import QVariant
from qgis.core.additions.edit import edit
from .utility import Allegato_first, Allegato_second
######################################################

url_template = 'file:///{0}?crs=epsg:4326&delimiter={1}&xField={2}&yField={3}'

class ADREMTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ADREMTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&adrem_tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ADREMTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/adrem_tool/myicon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'adrem tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&adrem_tool'),
                action)
            self.iface.removeToolBarIcon(action)

    def _make_main_view_layer(self):
        main_view_layer = QgsVectorLayer(self.dlg.filename_mainView, "main_view", 'ogr')
        if not main_view_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_mainView)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.m_v_layer = main_view_layer
        self.main_extent = main_view_layer.extent()
        _log_msg = "Success {} layer Loaded.".format(self.dlg.filename_mainView)
        iface.messageBar().pushMessage("ADREM INFO: ", 
            _log_msg,
            level=Qgis.Info)
        
    def _show_main_view_layer(self):
        sublayers = self.m_v_layer.dataProvider().subLayers()
        for subLayer in sublayers:
            geom_type = subLayer.split('!!::!!')[3]
            uri = "{}|layername=entities|geometrytype={}".format(self.dlg.filename_mainView, geom_type,)
            dfx_file_name = os.path.splitext(os.path.basename(self.dlg.filename_mainView))[0]
            layer_name = "{} - {}".format(dfx_file_name,geom_type,)
            #Create layer
            sub_vlayer = QgsVectorLayer(uri, layer_name, 'ogr')
            #Add layer to map
            sub_vlayer.setOpacity(0.9)
            QgsProject.instance().addMapLayer(sub_vlayer)

    def _get_boundary(self):
        bound_shp_layer = QgsVectorLayer(self.dlg.filename_boundary_shp, 'boudary', 'ogr')
        if not bound_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_boudary_shp)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        #self.bound_shp_layer = bound_shp_layer
        # check now if one need to convert
        bound_features = list(bound_shp_layer.getFeatures())
        need_to_convert = True
        for each in bound_features:
            if each.geometry().wkbType() == QgsWkbTypes.Polygon or \
                each.geometry().wkbType() == QgsWkbTypes.MultiPolygon:
                need_to_convert = False
            else:
                if each.geometry().wkbType() != QgsWkbTypes.MultiLineString:
                    msg = 'The type of boundary is unknown, try MultilineString or polygon'
                    iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                    raise Exception(msg)
                need_to_convert = True
        if need_to_convert:
            param_conv_lin2pol = {
                'INPUT' : bound_shp_layer, 
                'OUTPUT' : 'TEMPORARY_OUTPUT' }
            out_ =  processing.run('qgis:linestopolygons', param_conv_lin2pol)
            clip_polygon = out_['OUTPUT']
            clip_polygon.setName('clip_boundary')
            self.bound_shp_layer = clip_polygon
        else:
            self.bound_shp_layer = bound_shp_layer
        
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_boundary_shp)
        iface.messageBar().pushMessage("ADREM INFO: ", 
                _log_msg,
                level=Qgis.Info)

    def _show_boundary(self):
        self.bound_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.bound_shp_layer)

    def _industrial_layer(self):
        ind_shp_layer = QgsVectorLayer(self.dlg.filename_industrialShape, 'industrial_area', 'ogr')
        if not ind_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_industrialShape)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.ind_shp_layer = ind_shp_layer
        self.ind_shp_layer.setExtent(self.main_extent)
        self.ind_features = list(self.ind_shp_layer.getFeatures())
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_industrialShape)
        iface.messageBar().pushMessage("ADREM INFO: ", 
            _log_msg,
            level=Qgis.Info)
    def _show_industrial_layer(self):
        self.ind_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.ind_shp_layer)

    def _residential_layer(self):
        res_shp_layer = QgsVectorLayer(self.dlg.filename_residentialShape, 'residential_area', 'ogr')
        if not res_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_residentialShape)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.res_shp_layer = res_shp_layer
        self.res_shp_layer.setExtent(self.main_extent)
        self.res_features = list(self.res_shp_layer.getFeatures())
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_residentialShape)
        iface.messageBar().pushMessage("ADREM INFO: ", 
            _log_msg,
            level=Qgis.Info)

    def _show_residential_layer(self):
        self.res_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.res_shp_layer)

    def _process_csv_shallow(self):
        x_ = self.dlg._sha_x
        y_ = self.dlg._sha_y
        path = Path(r'{}'.format(self.dlg.filename_shallow_csv))
        delim = self.dlg.del_sha_csv
        uri = url_template.format(path,delim,x_,y_)
        sha_layer = QgsVectorLayer(uri, 'sha_loc_layer', 'delimitedtext')
        if not sha_layer.isValid():
            msg = 'Loading Layer from : {2} failed'.format(path)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        
        sha_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': sha_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        sha_layer.removeSelection()


        #clone_layer.setName('layer_sha')
        if self.dlg.filename_residentialShape and self.dlg.filename_industrialShape:
            clone_cap = clone_layer.dataProvider().capabilities()
            #print(clone_layer.dataProvider().capabilitiesString())
            if clone_cap & QgsVectorDataProvider.AddAttributes:
            #print("layer capable")
                flag_check = clone_layer.dataProvider().addAttributes(
                [QgsField("RI", QVariant.Int)]
                )
                assert(flag_check)
                clone_layer.updateFields()
                clone_layer.startEditing()
                for f in clone_layer.getFeatures():
                    for each in self.res_features:
                        if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                            or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                            is_res = each.geometry().contains(f.geometry())
                            f['RI'] = int(is_res)
                            clone_layer.updateFeature(f)
                assert(clone_layer.commitChanges())
            # now lets split
            param_split = {
                'INPUT' : clone_layer,
                'FIELD' : 'RI',
                'FILE_TYPE' : 0,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
                }
            res = processing.run('qgis:splitvectorlayer', param_split)
            ext_res = 'RI_1.gpkg'
            ext_ind = 'RI_0.gpkg'
            print(res)
            sha_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'sha_on_res', 'ogr')
            if not sha_res_splited.isValid():
                #print("res is valid")
                msg = 'Processing Layer from : {} failed. This error might happen if you provide a Residential use but it is empty.'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            sha_res_splited.setExtent(self.main_extent)
            self.sha_res_splited = sha_res_splited
            
            #QgsProject.instance().addMapLayer(sha_res_splited)

            sha_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'sha_on_ind', 'ogr')
            if not sha_res_splited.isValid():
                #print("ind valid")
                msg = 'Processing Layer from : {} failed. This error might happen if you provide a Industrial use but it is empty.'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            sha_ind_splited.setExtent(self.main_extent)
            self.sha_ind_splited = sha_ind_splited
            #QgsProject.instance().addMapLayer(sha_ind_splited)
        else:
            if self.dlg.filename_industrialShape:
                # clone_layer.setName('sha_on_ind')
                # self.sha_ind_splited = clone_layer
                self.sha_res_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.ind_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_ind = 'RI_1.gpkg'
                
                sha_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'sha_on_ind', 'ogr')
                if not sha_ind_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This error might happen if you provide a Industrial use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                    raise Exception(msg)
                sha_ind_splited.setExtent(self.main_extent)
                self.sha_ind_splited = sha_ind_splited

                

            else:
                clone_layer.setName('sha_on_res')
                self.sha_ind_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.res_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_res = 'RI_1.gpkg'
                
                sha_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'sha_on_res', 'ogr')
                if not sha_res_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This error might happen if you provide a Residential use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                    raise Exception(msg)
                sha_res_splited.setExtent(self.main_extent)
                self.sha_res_splited = sha_res_splited
                
        #QgsProject.instance().addMapLayer(clone_layer)

        ################################
        ########### Voronoi ############
        ################################
        if self.sha_res_splited:
            ###### point show ######
            QgsProject.instance().addMapLayer(self.sha_res_splited)
            ##############################
            parm_voronoi = {
                'INPUT' : self.sha_res_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            sha_vor_res = res['OUTPUT']
            sha_vor_res.setName('sha_vor_on_res')
            param_ = {
                    'INPUT' : sha_vor_res, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_res_cliped = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_res_cliped_by_bound', 'ogr')
            if not sha_vor_res_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            param_ = {
                    'INPUT' : sha_vor_res_cliped, 
                    'MASK' : self.res_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_res_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_res_cliped', 'ogr')
            if not sha_vor_res_cliped_.isValid():
                msg = 'Processing residential clipped Voronoi Layer on from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            
            

            #############################################################
            ext_cap = sha_vor_res_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(sha_vor_res_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.shallow_lim_res.keys())))
                ))
                
                assert(sha_vor_res_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(sha_vor_res_cliped_):
                    for f in sha_vor_res_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.shallow_lim_res:
                            if float(f[ke]) > self.shallow_lim_res[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            sha_vor_res_cliped_.updateFeature(f)

            self.sha_vor_res_cliped = sha_vor_res_cliped_
            # set_fill_color(self.sha_vor_res_cliped)
            # reCatLayer(self.sha_vor_res_cliped)
            # QgsProject.instance().addMapLayer(self.sha_vor_res_cliped)
            ############################################################
        if self.sha_ind_splited:

            # show points
            QgsProject.instance().addMapLayer(self.sha_ind_splited)
            # debug 
            parm_voronoi = {
                'INPUT' : self.sha_ind_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            sha_vor_ind = res['OUTPUT']
            sha_vor_ind.setName('sha_vor_on_ind')
            param_ = {
                    'INPUT' : sha_vor_ind, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_ind_cliped = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_ind_cliped_by_bound', 'ogr')
            if not sha_vor_ind_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            # debug 
            # QgsProject.instance().addMapLayer(sha_vor_ind_cliped)
            # debug
            param_ = {
                    'INPUT' : sha_vor_ind_cliped, 
                    'MASK' : self.ind_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_ind_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_ind_cliped', 'ogr')
            if not sha_vor_ind_cliped_.isValid():
                msg = 'Processing Industrial clipped Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)

            ###########################################################
            ext_cap = sha_vor_ind_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(sha_vor_ind_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.shallow_lim_ind.keys())))
                ))

                assert(sha_vor_ind_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(sha_vor_ind_cliped_):
                    for f in sha_vor_ind_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.shallow_lim_ind:
                            if float(f[ke]) > self.shallow_lim_ind[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            sha_vor_ind_cliped_.updateFeature(f)
            self.sha_vor_ind_cliped = sha_vor_ind_cliped_
            # set_fill_color(self.sha_vor_ind_cliped)
            #reCatLayer(self.sha_vor_ind_cliped)
            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
            ###########################################################
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_shallow_csv)
        iface.messageBar().pushMessage("ADREM INFO: ", 
            _log_msg,
            level=Qgis.Info)


    def _process_csv_deep_soil(self):
        x_ = self.dlg._deep_x
        y_ = self.dlg._deep_y
        path = Path(r'{}'.format(self.dlg.filename_deep_csv))
        delim = self.dlg.del_deep_csv 
        uri = url_template.format(path,delim,x_,y_)
        deep_layer = QgsVectorLayer(uri, 'deep_loc_layer', 'delimitedtext')
        if not deep_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        deep_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': deep_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        deep_layer.removeSelection()
        
        if self.dlg.filename_residentialShape and self.dlg.filename_industrialShape:
            clone_cap = clone_layer.dataProvider().capabilities()
            #print(clone_layer.dataProvider().capabilitiesString())
            if clone_cap & QgsVectorDataProvider.AddAttributes:
            #print("layer capable")
                flag_check = clone_layer.dataProvider().addAttributes(
                [QgsField("RI", QVariant.Int)]
                )
                assert(flag_check)
                clone_layer.updateFields()
                clone_layer.startEditing()
                for f in clone_layer.getFeatures():
                    for each in self.res_features:
                        if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                            or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                            is_res = each.geometry().contains(f.geometry())
                            f['RI'] = int(is_res)
                            clone_layer.updateFeature(f)
                assert(clone_layer.commitChanges())
            # now lets split
            param_split = {
                'INPUT' : clone_layer,
                'FIELD' : 'RI',
                'FILE_TYPE' : 0,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
                }
            res = processing.run('qgis:splitvectorlayer', param_split)
            ext_res = 'RI_1.gpkg'
            ext_ind = 'RI_0.gpkg'

            deep_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'deep_on_res', 'ogr')
            if not deep_res_splited.isValid():
                msg = 'Processing Layer from : {} failed. This error might happen if you provide a Residential use but it is empty.'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            deep_res_splited.setExtent(self.main_extent)
            self.deep_res_splited = deep_res_splited

            deep_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'deep_on_ind', 'ogr')
            if not deep_ind_splited.isValid():
                #print("ind valid")
                msg = 'Processing Layer from : {} failed. This error might happen if you provide a Industrial use but it is empty.'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            deep_ind_splited.setExtent(self.main_extent)
            self.deep_ind_splited = deep_ind_splited
            
        else:
            if self.dlg.filename_industrialShape:
                
                self.deep_res_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                   
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.ind_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_ind = 'RI_1.gpkg'
                
                deep_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'deep_on_ind', 'ogr')
                if not deep_ind_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This error might happen if you provide a Industrial use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                    raise Exception(msg)
                deep_ind_splited.setExtent(self.main_extent)
                self.deep_ind_splited = deep_ind_splited

            else:
                # clone_layer.setName('deep_on_res')
                self.deep_ind_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.res_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_res = 'RI_1.gpkg'
                
                deep_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'deep_on_res', 'ogr')
                if not deep_res_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This error might happen if you provide a Residential use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                    raise Exception(msg)
                deep_res_splited.setExtent(self.main_extent)
                self.deep_res_splited = deep_res_splited
        #QgsProject.instance().addMapLayer(clone_layer)
        #################
        #### Voronoi ####
        #################
        if self.deep_res_splited:

            ######### points show debug #########
            QgsProject.instance().addMapLayer(self.deep_res_splited)
            #####################################
            parm_voronoi = {
                'INPUT' : self.deep_res_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            deep_vor_res = res['OUTPUT']
            deep_vor_res.setName('deep_vor_on_res')
            param_ = {
                    'INPUT' : deep_vor_res, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_res_cliped = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_res_cliped_by_bound', 'ogr')
            if not deep_vor_res_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            param_ = {
                    'INPUT' : deep_vor_res_cliped, 
                    'MASK' : self.res_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_res_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_res_cliped', 'ogr')
            if not deep_vor_res_cliped_.isValid():
                msg = 'Processing Residential voronoi clipped Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            
            
            ###########################################################
            ext_cap = deep_vor_res_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(deep_vor_res_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.deep_lim_res.keys())))
                ))

                assert(deep_vor_res_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated',QVariant.Int)]
                ))

                with edit(deep_vor_res_cliped_):
                    for f in deep_vor_res_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.deep_lim_res:
                            if float(f[ke]) > self.deep_lim_res[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            deep_vor_res_cliped_.updateFeature(f)
            self.deep_vor_res_cliped = deep_vor_res_cliped_
            #set_fill_color(self.deep_vor_res_cliped)
            #QgsProject.instance().addMapLayer(self.deep_vor_res_cliped)
            ###########################################################
        
        if self.deep_ind_splited:

            # points show
            QgsProject.instance().addMapLayer(self.deep_ind_splited)
            # debug 
            parm_voronoi = {
                'INPUT' : self.deep_ind_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            deep_vor_ind = res['OUTPUT']
            deep_vor_ind.setName('deep_vor_on_ind')
            param_ = {
                    'INPUT' : deep_vor_ind, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_ind_cliped = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_ind_cliped_by_bound', 'ogr')
            if not deep_vor_ind_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            # debug 
            # QgsProject.instance().addMapLayer(sha_vor_ind_cliped)
            # debug
            param_ = {
                    'INPUT' : deep_vor_ind_cliped, 
                    'MASK' : self.ind_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_ind_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_ind_cliped', 'ogr')
            if not deep_vor_ind_cliped_.isValid():
                msg = 'Processing industrial voronoi clipped Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
            #set_fill_color(sha_vor_ind_cliped)

            ###########################################################
            ext_cap = deep_vor_ind_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(deep_vor_ind_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.deep_lim_ind.keys())))
                ))

                assert(deep_vor_ind_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(deep_vor_ind_cliped_):
                    for f in deep_vor_ind_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.deep_lim_ind:
                            if float(f[ke]) > self.deep_lim_ind[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            deep_vor_ind_cliped_.updateFeature(f)
            self.deep_vor_ind_cliped = deep_vor_ind_cliped_
            # set_fill_color(self.deep_vor_ind_cliped)
            # QgsProject.instance().addMapLayer(self.deep_vor_ind_cliped)
            ###########################################################

        _log_msg = "Success {} layer loader.".format(self.dlg.filename_shallow_csv)
        iface.messageBar().pushMessage("ADREM INFO: ", 
                        _log_msg,
                        level=Qgis.Info)


    def _process_csv_aquifer(self):
        x_ = self.dlg._aqui_x
        y_ = self.dlg._aqui_y
        path = Path(r'{}'.format(self.dlg.filename_aquifer_csv))
        delim = self.dlg.del_aqui_csv 
        uri = url_template.format(path,delim,x_,y_)
        aquifer_layer = QgsVectorLayer(uri, 'aquifer', 'delimitedtext')
        if not aquifer_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
        
        aquifer_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': aquifer_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        aquifer_layer.removeSelection()
        

        self.aquifer_loc_layer = clone_layer
        self.aquifer_loc_layer.setName('aquifer_cliped')
        self.aquifer_loc_layer.setExtent(self.main_extent)

        ######### points show debug #########
        QgsProject.instance().addMapLayer(self.aquifer_loc_layer)
        #####################################

        ### voronoi
        parm_voronoi = {
                'INPUT' : self.aquifer_loc_layer,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
        res = processing.run('qgis:voronoipolygons', parm_voronoi)
        aquifer_vor = res['OUTPUT']
        aquifer_vor.setName('aquifer_vor')
        param_ = {
                    'INPUT' : aquifer_vor, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
        res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
        aquifer_vor_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'aquifer_vor_cliped_by_bound', 'ogr')
        if not aquifer_vor_cliped_.isValid():
            msg = 'Processing Voronoi Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
            raise Exception(msg)
            
        ###########################################################
        ext_cap = aquifer_vor_cliped_.dataProvider().capabilities()
        if ext_cap & QgsVectorDataProvider.AddAttributes:
            assert(aquifer_vor_cliped_.dataProvider().addAttributes(
                list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                list(self.aquifer_lim.keys())))
                ))

            assert(aquifer_vor_cliped_.dataProvider().addAttributes(
                [QgsField('isContaminated',QVariant.Int)]
            ))

            with edit(aquifer_vor_cliped_):
                for f in aquifer_vor_cliped_.getFeatures():
                    f['isContaminated'] = 0
                    for ke in self.aquifer_lim:
                        if float(f[ke]) > self.aquifer_lim[ke]:
                            f['{}_cont'.format(ke)] = 1
                            f['isContaminated'] = 1
                        else:
                            f['{}_cont'.format(ke)] = 0
                        aquifer_vor_cliped_.updateFeature(f)
        self.aquifer_vor_cliped = aquifer_vor_cliped_
        # set_fill_color(self.aquifer_vor_cliped)
        # QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)
        ###########################################################
        #QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)


        
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_aquifer_csv)
        iface.messageBar().pushMessage("ADREM INFO: ", 
            _log_msg,
            level=Qgis.Info)

    # def _show_aquifer(self):
    #     QgsProject.instance().addMapLayer(self.aquifer_loc_layer)

    def do_the_math(self):
        allegato_f = Allegato_first()
        allegato_s = Allegato_second()
        if self.dlg.filename_shallow_csv:
            self.shallow_lim_ind = {}
            self.shallow_lim_res = {}
            for each in self.dlg.shallow_combo:
                try:
                    self.shallow_lim_ind[each] = float(allegato_f._get_lim_ind(each))
                    self.shallow_lim_res[each] = float(allegato_f._get_lim_res(each))
                except KeyError:
                    continue
            if not self.shallow_lim_ind or not self.shallow_lim_res:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_shallow_csv)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
        if self.dlg.filename_deep_csv:
            self.deep_lim_ind = {}
            self.deep_lim_res = {}
            for each in self.dlg.deep_combo:
                try:
                    self.deep_lim_ind[each] = float(allegato_f._get_lim_ind(each))
                    self.deep_lim_res[each] = float(allegato_f._get_lim_res(each))
                except KeyError:
                    continue
            if not self.deep_lim_ind or not self.deep_lim_res:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_deep_csv)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
        if self.dlg.filename_aquifer_csv:
            self.aquifer_lim = {}
            for each in self.dlg.aquifer_combo:
                try:
                    self.aquifer_lim[each] = float(allegato_s._get_lim(each))
                except KeyError:
                    continue
            if not self.aquifer_lim:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_aquifer_csv)
                iface.messageBar().pushMessage("Error", msg, level=Qgis.Critical)
                raise Exception(msg)
        
    def AnalisisAndOutput(self):
        try:
            if self.sha_vor_ind_cliped:
                with edit(self.sha_vor_ind_cliped):
                    for f in self.sha_vor_ind_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            f['isContaminated'] = 1
                            buff = f.geometry().buffer(10,2)
                            for g in self.sha_vor_ind_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            f['isContaminated'] = 0
                                            break
                            self.sha_vor_ind_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.sha_vor_ind_cliped)
                QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
        except AttributeError:
            pass
        
        try:
            if self.sha_vor_res_cliped:
                with edit(self.sha_vor_res_cliped):
                    for f in self.sha_vor_res_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            f['isContaminated'] = 1
                            buff = f.geometry().buffer(10,2)
                            for g in self.sha_vor_res_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            f['isContaminated'] = 0
                                            break
                            self.sha_vor_res_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.sha_vor_res_cliped)
                QgsProject.instance().addMapLayer(self.sha_vor_res_cliped)
        except AttributeError:
            pass

        try:
            if self.deep_vor_res_cliped:
                with edit(self.deep_vor_res_cliped):
                    for f in self.deep_vor_res_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            f['isContaminated'] = 1
                            buff = f.geometry().buffer(10,2)
                            for g in self.deep_vor_res_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            f['isContaminated'] = 0
                                            break
                            self.deep_vor_res_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.deep_vor_res_cliped)
                QgsProject.instance().addMapLayer(self.deep_vor_res_cliped)
        except AttributeError:
            pass
        
        try:
            if self.deep_vor_ind_cliped:
                with edit(self.deep_vor_ind_cliped):
                    for f in self.deep_vor_ind_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            f['isContaminated'] = 1
                            buff = f.geometry().buffer(10,2)
                            for g in self.deep_vor_ind_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            f['isContaminated'] = 0
                                            break
                            self.deep_vor_ind_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.deep_vor_ind_cliped)
                QgsProject.instance().addMapLayer(self.deep_vor_ind_cliped)
        except AttributeError:
            pass

        try:
            if self.aquifer_vor_cliped:
                with edit(self.aquifer_vor_cliped):
                    for f in self.aquifer_vor_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            f['isContaminated'] = 1
                            buff = f.geometry().buffer(10,2)
                            for g in self.aquifer_vor_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            f['isContaminated'] = 0
                                            break
                            self.aquifer_vor_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.aquifer_vor_cliped)
                QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)
        except AttributeError:
            pass



    def _show_help(self):
        help_file = 'file:///{0}'.format(Path(os.path.join(os.path.dirname(__file__),'help/build/html/index.html')))
        QDesktopServices.openUrl(QUrl(help_file))

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ADREMToolDialog()

        # windows title
        self.dlg.setWindowTitle('ADREM tool - 1.0.0')
        # set help
        self.dlg.buttonBox_help.helpRequested.connect(self._show_help)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:# == QFileDialog.rejected:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #return
            self._make_main_view_layer()
            self._show_main_view_layer()
            self._get_boundary()
            self._show_boundary()
        ## if residential
            if self.dlg.filename_industrialShape != "":
                self._industrial_layer()
                self._show_industrial_layer()
            if self.dlg.filename_residentialShape != "":
                self._residential_layer()
                self._show_residential_layer()
           
            self.do_the_math()
            
            if self.dlg.filename_shallow_csv:
                self._process_csv_shallow()
            if self.dlg.filename_deep_csv:
                self._process_csv_deep_soil()
            if self.dlg.filename_aquifer_csv:
                self._process_csv_aquifer()

            self.AnalisisAndOutput()

            self.dlg.close()

            

def set_fill_color(layer):
    _props = layer.renderer().symbol().symbolLayer(0).properties()
    #_props['color'] = '232,113,141,170'
    actual_color = _props['color']
    a = actual_color.split(',')
    a[-1] = '170'
    _props['color'] = ','.join(a)
    layer.renderer().setSymbol(QgsFillSymbol.createSimple(_props))

def reCatLayer(layer):
    categories = QgsCategorizedSymbolRenderer()
    contaminated_sym = QgsFillSymbol.createSimple({'color':'255,0,0,120'})
    clean_sym = QgsFillSymbol.createSimple({'color':'0,255,0,120'})
    cat_cont = QgsRendererCategory('1',contaminated_sym,'contaminated')
    cat_clean = QgsRendererCategory('0',clean_sym, 'clean')

    categories.addCategory(cat_cont)
    categories.addCategory(cat_clean)

    categories.setClassAttribute('isContaminated')

    layer.setRenderer(categories)
