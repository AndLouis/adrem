# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ADREMTool
                                 A QGIS plugin
 No desrciption yet
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-05
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Louis- FULL 2021
        email                : louis.andrianaivo@polito.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QUrl
from qgis.PyQt.QtGui import QIcon, QDesktopServices, QStandardItemModel, QStandardItem
from qgis.PyQt.QtWidgets import QAction, QFileDialog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .adrem_tool_dialog import ADREMToolDialog
################################################
from .select_sources import SelectSourceDialog #
################################################

import os.path
################################################
from pathlib import Path
import os
import sys
import math

from qgis.core import (
    QgsVectorLayer, 
    QgsProject, 
    Qgis, 
    QgsVectorDataProvider, 
    QgsField,
    QgsFields,
    QgsFeature,
    QgsPointXY,
    QgsWkbTypes,
    QgsFillSymbol,
    QgsCategorizedSymbolRenderer,
    QgsRendererCategory,
    QgsVectorFileWriter,
    QgsMessageLog)
import os, sys
from qgis.utils import iface

import processing
from PyQt5.QtCore import QVariant
from qgis.core.additions.edit import edit
from .utility import Allegato_first, Allegato_second, GroupName, MatrixTech
######################################################

url_template = 'file:///{0}?crs=epsg:4326&delimiter={1}&xField={2}&yField={3}'

class ADREMTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ADREMTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&adrem_tool')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.gpname = GroupName()
        self.matrixtech = MatrixTech() 

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ADREMTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/adrem_tool/myicon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'adrem tool'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&adrem_tool'),
                action)
            self.iface.removeToolBarIcon(action)

    def _make_main_view_layer(self):
        main_view_layer = QgsVectorLayer(self.dlg.filename_mainView, "main_view", 'ogr')
        if not main_view_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_mainView)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.m_v_layer = main_view_layer
        self.main_extent = main_view_layer.extent()
        _log_msg = "Success {} layer Loaded.".format(self.dlg.filename_mainView)
        iface.messageBar().pushMessage("ADREM INFO ", 
            _log_msg,
            level=Qgis.Info)
        
    def _show_main_view_layer(self):
        sublayers = self.m_v_layer.dataProvider().subLayers()
        for subLayer in sublayers:
            geom_type = subLayer.split('!!::!!')[3]
            uri = "{}|layername=entities|geometrytype={}".format(self.dlg.filename_mainView, geom_type,)
            dfx_file_name = os.path.splitext(os.path.basename(self.dlg.filename_mainView))[0]
            layer_name = "{} - {}".format(dfx_file_name,geom_type,)
            #Create layer
            sub_vlayer = QgsVectorLayer(uri, layer_name, 'ogr')
            #Add layer to map
            sub_vlayer.setOpacity(0.9)
            QgsProject.instance().addMapLayer(sub_vlayer)

    def _get_boundary(self):
        bound_shp_layer = QgsVectorLayer(self.dlg.filename_boundary_shp, 'boudary', 'ogr')
        if not bound_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_boudary_shp)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        #self.bound_shp_layer = bound_shp_layer
        # check now if one need to convert
        bound_features = list(bound_shp_layer.getFeatures())
        need_to_convert = True
        for each in bound_features:
            if each.geometry().wkbType() == QgsWkbTypes.Polygon or \
                each.geometry().wkbType() == QgsWkbTypes.MultiPolygon:
                need_to_convert = False
            else:
                if each.geometry().wkbType() != QgsWkbTypes.MultiLineString:
                    msg = 'The type of boundary is unknown, try MultilineString or polygon'
                    iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                    raise Exception(msg)
                need_to_convert = True
        if need_to_convert:
            param_conv_lin2pol = {
                'INPUT' : bound_shp_layer, 
                'OUTPUT' : 'TEMPORARY_OUTPUT' }
            out_ =  processing.run('qgis:linestopolygons', param_conv_lin2pol)
            clip_polygon = out_['OUTPUT']
            clip_polygon.setName('clip_boundary')
            self.bound_shp_layer = clip_polygon
        else:
            self.bound_shp_layer = bound_shp_layer
        
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_boundary_shp)
        iface.messageBar().pushMessage("ADREM INFO ", 
                _log_msg,
                level=Qgis.Info)

    def _show_boundary(self):
        self.bound_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.bound_shp_layer)

    def _industrial_layer(self):
        ind_shp_layer = QgsVectorLayer(self.dlg.filename_industrialShape, 'industrial_area', 'ogr')
        if not ind_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_industrialShape)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.ind_shp_layer = ind_shp_layer
        self.ind_shp_layer.setExtent(self.main_extent)
        self.ind_features = list(self.ind_shp_layer.getFeatures())
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_industrialShape)
        iface.messageBar().pushMessage("ADREM INFO ", 
            _log_msg,
            level=Qgis.Info)
    def _show_industrial_layer(self):
        self.ind_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.ind_shp_layer)

    def _residential_layer(self):
        res_shp_layer = QgsVectorLayer(self.dlg.filename_residentialShape, 'residential_area', 'ogr')
        if not res_shp_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(self.dlg.filename_residentialShape)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        self.res_shp_layer = res_shp_layer
        self.res_shp_layer.setExtent(self.main_extent)
        self.res_features = list(self.res_shp_layer.getFeatures())
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_residentialShape)
        iface.messageBar().pushMessage("ADREM INFO ", 
            _log_msg,
            level=Qgis.Info)

    def _show_residential_layer(self):
        self.res_shp_layer.setOpacity(0.2)
        QgsProject.instance().addMapLayer(self.res_shp_layer)

    def _process_csv_shallow(self):
        x_ = self.dlg._sha_x
        y_ = self.dlg._sha_y
        path = Path(r'{}'.format(self.dlg.filename_shallow_csv))
        delim = self.dlg.del_sha_csv
        uri = url_template.format(path,delim,x_,y_)
        sha_layer = QgsVectorLayer(uri, 'sha_loc_layer', 'delimitedtext')
        if not sha_layer.isValid():
            msg = 'Loading Layer from : {2} failed'.format(path)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        
        sha_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': sha_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        sha_layer.removeSelection()


        #clone_layer.setName('layer_sha')
        if self.dlg.filename_residentialShape and self.dlg.filename_industrialShape:
            clone_cap = clone_layer.dataProvider().capabilities()
            #print(clone_layer.dataProvider().capabilitiesString())
            if clone_cap & QgsVectorDataProvider.AddAttributes:
            #print("layer capable")
                flag_check = clone_layer.dataProvider().addAttributes(
                [QgsField("RI", QVariant.Int)]
                )
                assert(flag_check)
                clone_layer.updateFields()
                clone_layer.startEditing()
                for f in clone_layer.getFeatures():
                    for each in self.res_features:
                        if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                            or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                            is_res = each.geometry().contains(f.geometry())
                            f['RI'] = int(is_res)
                            clone_layer.updateFeature(f)
                assert(clone_layer.commitChanges())
            # now lets split
            param_split = {
                'INPUT' : clone_layer,
                'FIELD' : 'RI',
                'FILE_TYPE' : 0,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
                }
            res = processing.run('qgis:splitvectorlayer', param_split)
            ext_res = 'RI_1.gpkg'
            ext_ind = 'RI_0.gpkg'
            print(res)
            sha_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'sha_on_res', 'ogr')
            if not sha_res_splited.isValid():
                #print("res is valid")
                msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Residential use but it is empty.'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            sha_res_splited.setExtent(self.main_extent)
            self.sha_res_splited = sha_res_splited
            
            #QgsProject.instance().addMapLayer(sha_res_splited)

            sha_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'sha_on_ind', 'ogr')
            if not sha_res_splited.isValid():
                #print("ind valid")
                msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Industrial use but it is empty.'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            sha_ind_splited.setExtent(self.main_extent)
            self.sha_ind_splited = sha_ind_splited
            #QgsProject.instance().addMapLayer(sha_ind_splited)
        else:
            if self.dlg.filename_industrialShape:
                # clone_layer.setName('sha_on_ind')
                # self.sha_ind_splited = clone_layer
                self.sha_res_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.ind_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_ind = 'RI_1.gpkg'
                
                sha_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'sha_on_ind', 'ogr')
                if not sha_ind_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Industrial use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                    raise Exception(msg)
                sha_ind_splited.setExtent(self.main_extent)
                self.sha_ind_splited = sha_ind_splited

                

            else:
                clone_layer.setName('sha_on_res')
                self.sha_ind_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.res_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_res = 'RI_1.gpkg'
                
                sha_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'sha_on_res', 'ogr')
                if not sha_res_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Residential use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                    raise Exception(msg)
                sha_res_splited.setExtent(self.main_extent)
                self.sha_res_splited = sha_res_splited
                
        #QgsProject.instance().addMapLayer(clone_layer)

        ################################
        ########### Voronoi ############
        ################################
        if self.sha_res_splited:
            ###### point show ######
            QgsProject.instance().addMapLayer(self.sha_res_splited)
            ##############################
            parm_voronoi = {
                'INPUT' : self.sha_res_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            sha_vor_res = res['OUTPUT']
            sha_vor_res.setName('sha_vor_on_res')
            param_ = {
                    'INPUT' : sha_vor_res, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_res_cliped = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_res_cliped_by_bound', 'ogr')
            if not sha_vor_res_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            param_ = {
                    'INPUT' : sha_vor_res_cliped, 
                    'MASK' : self.res_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_res_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_res_cliped', 'ogr')
            if not sha_vor_res_cliped_.isValid():
                msg = 'Processing residential clipped Voronoi Layer on from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            
            

            #############################################################
            ext_cap = sha_vor_res_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(sha_vor_res_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.shallow_lim_res.keys())))
                ))
                
                assert(sha_vor_res_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(sha_vor_res_cliped_):
                    for f in sha_vor_res_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.shallow_lim_res:
                            if float(f[ke]) > self.shallow_lim_res[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            sha_vor_res_cliped_.updateFeature(f)

            self.sha_vor_res_cliped = sha_vor_res_cliped_
            # set_fill_color(self.sha_vor_res_cliped)
            # reCatLayer(self.sha_vor_res_cliped)
            # QgsProject.instance().addMapLayer(self.sha_vor_res_cliped)
            ############################################################
        if self.sha_ind_splited:

            # show points
            QgsProject.instance().addMapLayer(self.sha_ind_splited)
            # debug 
            parm_voronoi = {
                'INPUT' : self.sha_ind_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            sha_vor_ind = res['OUTPUT']
            sha_vor_ind.setName('sha_vor_on_ind')
            param_ = {
                    'INPUT' : sha_vor_ind, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_ind_cliped = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_ind_cliped_by_bound', 'ogr')
            if not sha_vor_ind_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            # debug 
            # QgsProject.instance().addMapLayer(sha_vor_ind_cliped)
            # debug
            param_ = {
                    'INPUT' : sha_vor_ind_cliped, 
                    'MASK' : self.ind_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            sha_vor_ind_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'sha_vor_on_ind_cliped', 'ogr')
            if not sha_vor_ind_cliped_.isValid():
                msg = 'Processing Industrial clipped Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)

            ###########################################################
            ext_cap = sha_vor_ind_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(sha_vor_ind_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.shallow_lim_ind.keys())))
                ))

                assert(sha_vor_ind_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(sha_vor_ind_cliped_):
                    for f in sha_vor_ind_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.shallow_lim_ind:
                            if float(f[ke]) > self.shallow_lim_ind[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            sha_vor_ind_cliped_.updateFeature(f)
            self.sha_vor_ind_cliped = sha_vor_ind_cliped_
            # set_fill_color(self.sha_vor_ind_cliped)
            #reCatLayer(self.sha_vor_ind_cliped)
            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
            ###########################################################
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_shallow_csv)
        iface.messageBar().pushMessage("ADREM INFO ", 
            _log_msg,
            level=Qgis.Info)


    def _process_csv_deep_soil(self):
        x_ = self.dlg._deep_x
        y_ = self.dlg._deep_y
        path = Path(r'{}'.format(self.dlg.filename_deep_csv))
        delim = self.dlg.del_deep_csv 
        uri = url_template.format(path,delim,x_,y_)
        deep_layer = QgsVectorLayer(uri, 'deep_loc_layer', 'delimitedtext')
        if not deep_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        deep_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': deep_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        deep_layer.removeSelection()
        
        if self.dlg.filename_residentialShape and self.dlg.filename_industrialShape:
            clone_cap = clone_layer.dataProvider().capabilities()
            #print(clone_layer.dataProvider().capabilitiesString())
            if clone_cap & QgsVectorDataProvider.AddAttributes:
            #print("layer capable")
                flag_check = clone_layer.dataProvider().addAttributes(
                [QgsField("RI", QVariant.Int)]
                )
                assert(flag_check)
                clone_layer.updateFields()
                clone_layer.startEditing()
                for f in clone_layer.getFeatures():
                    for each in self.res_features:
                        if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                            or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                            is_res = each.geometry().contains(f.geometry())
                            f['RI'] = int(is_res)
                            clone_layer.updateFeature(f)
                assert(clone_layer.commitChanges())
            # now lets split
            param_split = {
                'INPUT' : clone_layer,
                'FIELD' : 'RI',
                'FILE_TYPE' : 0,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
                }
            res = processing.run('qgis:splitvectorlayer', param_split)
            ext_res = 'RI_1.gpkg'
            ext_ind = 'RI_0.gpkg'

            deep_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'deep_on_res', 'ogr')
            if not deep_res_splited.isValid():
                msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Residential use but it is empty.'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            deep_res_splited.setExtent(self.main_extent)
            self.deep_res_splited = deep_res_splited

            deep_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'deep_on_ind', 'ogr')
            if not deep_ind_splited.isValid():
                #print("ind valid")
                msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Industrial use but it is empty.'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            deep_ind_splited.setExtent(self.main_extent)
            self.deep_ind_splited = deep_ind_splited
            
        else:
            if self.dlg.filename_industrialShape:
                
                self.deep_res_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                   
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.ind_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_ind = 'RI_1.gpkg'
                
                deep_ind_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_ind, 'deep_on_ind', 'ogr')
                if not deep_ind_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Industrial use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                    raise Exception(msg)
                deep_ind_splited.setExtent(self.main_extent)
                self.deep_ind_splited = deep_ind_splited

            else:
                # clone_layer.setName('deep_on_res')
                self.deep_ind_splited = None
                clone_cap = clone_layer.dataProvider().capabilities()
                #print(clone_layer.dataProvider().capabilitiesString())
                if clone_cap & QgsVectorDataProvider.AddAttributes:
                    #print("layer capable")
                    flag_check = clone_layer.dataProvider().addAttributes(
                        [QgsField("RI", QVariant.Int)]
                        )
                    assert(flag_check)
                    with edit(clone_layer):
                        for f in clone_layer.getFeatures():
                            for each in self.res_features:
                                if each.geometry().wkbType() == QgsWkbTypes.MultiPolygon \
                                    or each.geometry().wkbType() == QgsWkbTypes.Polygon:
                                    is_ind = each.geometry().contains(f.geometry())
                                    f['RI'] = int(is_ind)
                                    clone_layer.updateFeature(f)
                ## split the important 
                param_split = {
                    'INPUT' : clone_layer,
                    'FIELD' : 'RI',
                    'FILE_TYPE' : 0,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                res = processing.run('qgis:splitvectorlayer', param_split)
                ext_res = 'RI_1.gpkg'
                
                deep_res_splited = QgsVectorLayer(res['OUTPUT'] + '/' + ext_res, 'deep_on_res', 'ogr')
                if not deep_res_splited.isValid():
                    msg = 'Processing Layer from : {} failed. This ERROR might happen if you provide a Residential use but it is empty.'.format(path)
                    iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                    raise Exception(msg)
                deep_res_splited.setExtent(self.main_extent)
                self.deep_res_splited = deep_res_splited
        #QgsProject.instance().addMapLayer(clone_layer)
        #################
        #### Voronoi ####
        #################
        if self.deep_res_splited:

            ######### points show debug #########
            QgsProject.instance().addMapLayer(self.deep_res_splited)
            #####################################
            parm_voronoi = {
                'INPUT' : self.deep_res_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            deep_vor_res = res['OUTPUT']
            deep_vor_res.setName('deep_vor_on_res')
            param_ = {
                    'INPUT' : deep_vor_res, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_res_cliped = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_res_cliped_by_bound', 'ogr')
            if not deep_vor_res_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            param_ = {
                    'INPUT' : deep_vor_res_cliped, 
                    'MASK' : self.res_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_res_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_res_cliped', 'ogr')
            if not deep_vor_res_cliped_.isValid():
                msg = 'Processing Residential voronoi clipped Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            
            
            ###########################################################
            ext_cap = deep_vor_res_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(deep_vor_res_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.deep_lim_res.keys())))
                ))

                assert(deep_vor_res_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated',QVariant.Int)]
                ))

                with edit(deep_vor_res_cliped_):
                    for f in deep_vor_res_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.deep_lim_res:
                            if float(f[ke]) > self.deep_lim_res[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            deep_vor_res_cliped_.updateFeature(f)
            self.deep_vor_res_cliped = deep_vor_res_cliped_
            #set_fill_color(self.deep_vor_res_cliped)
            #QgsProject.instance().addMapLayer(self.deep_vor_res_cliped)
            ###########################################################
        
        if self.deep_ind_splited:

            # points show
            QgsProject.instance().addMapLayer(self.deep_ind_splited)
            # debug 
            parm_voronoi = {
                'INPUT' : self.deep_ind_splited,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
            res = processing.run('qgis:voronoipolygons', parm_voronoi)
            deep_vor_ind = res['OUTPUT']
            deep_vor_ind.setName('deep_vor_on_ind')
            param_ = {
                    'INPUT' : deep_vor_ind, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_ind_cliped = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_ind_cliped_by_bound', 'ogr')
            if not deep_vor_ind_cliped.isValid():
                msg = 'Processing Voronoi Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            # debug 
            # QgsProject.instance().addMapLayer(sha_vor_ind_cliped)
            # debug
            param_ = {
                    'INPUT' : deep_vor_ind_cliped, 
                    'MASK' : self.ind_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
            res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
            deep_vor_ind_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'deep_vor_on_ind_cliped', 'ogr')
            if not deep_vor_ind_cliped_.isValid():
                msg = 'Processing industrial voronoi clipped Layer from : {} failed'.format(path)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
            #set_fill_color(sha_vor_ind_cliped)

            ###########################################################
            ext_cap = deep_vor_ind_cliped_.dataProvider().capabilities()
            if ext_cap & QgsVectorDataProvider.AddAttributes:
                assert(deep_vor_ind_cliped_.dataProvider().addAttributes(
                    list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                    list(self.deep_lim_ind.keys())))
                ))

                assert(deep_vor_ind_cliped_.dataProvider().addAttributes(
                    [QgsField('isContaminated', QVariant.Int)]
                ))

                with edit(deep_vor_ind_cliped_):
                    for f in deep_vor_ind_cliped_.getFeatures():
                        f['isContaminated'] = 0
                        for ke in self.deep_lim_ind:
                            if float(f[ke]) > self.deep_lim_ind[ke]:
                                f['{}_cont'.format(ke)] = 1
                                f['isContaminated'] = 1
                            else:
                                f['{}_cont'.format(ke)] = 0
                            deep_vor_ind_cliped_.updateFeature(f)
            self.deep_vor_ind_cliped = deep_vor_ind_cliped_
            # set_fill_color(self.deep_vor_ind_cliped)
            # QgsProject.instance().addMapLayer(self.deep_vor_ind_cliped)
            ###########################################################

        _log_msg = "Success {} layer loader.".format(self.dlg.filename_shallow_csv)
        iface.messageBar().pushMessage("ADREM INFO ", 
                        _log_msg,
                        level=Qgis.Info)


    def _process_csv_aquifer(self):
        x_ = self.dlg._aqui_x
        y_ = self.dlg._aqui_y
        path = Path(r'{}'.format(self.dlg.filename_aquifer_csv))
        delim = self.dlg.del_aqui_csv 
        uri = url_template.format(path,delim,x_,y_)
        aquifer_layer = QgsVectorLayer(uri, 'aquifer', 'delimitedtext')
        if not aquifer_layer.isValid():
            msg = 'Loading Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
        
        aquifer_layer.selectAll()
        clone_layer = processing.run("native:saveselectedfeatures",
                    {'INPUT': aquifer_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        aquifer_layer.removeSelection()
        

        self.aquifer_loc_layer = clone_layer
        self.aquifer_loc_layer.setName('aquifer_cliped')
        self.aquifer_loc_layer.setExtent(self.main_extent)

        ######### points show debug #########
        QgsProject.instance().addMapLayer(self.aquifer_loc_layer)
        #####################################

        ### voronoi
        parm_voronoi = {
                'INPUT' : self.aquifer_loc_layer,
                'OUTPUT' : 'TEMPORARY_OUTPUT'
            }
            
        res = processing.run('qgis:voronoipolygons', parm_voronoi)
        aquifer_vor = res['OUTPUT']
        aquifer_vor.setName('aquifer_vor')
        param_ = {
                    'INPUT' : aquifer_vor, 
                    'MASK' : self.bound_shp_layer,
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
         
        res_1 = processing.run('gdal:clipvectorbypolygon', param_)
    
        aquifer_vor_cliped_ = QgsVectorLayer(res_1['OUTPUT'],'aquifer_vor_cliped_by_bound', 'ogr')
        if not aquifer_vor_cliped_.isValid():
            msg = 'Processing Voronoi Layer from : {} failed'.format(path)
            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
            raise Exception(msg)
            
        ###########################################################
        ext_cap = aquifer_vor_cliped_.dataProvider().capabilities()
        if ext_cap & QgsVectorDataProvider.AddAttributes:
            assert(aquifer_vor_cliped_.dataProvider().addAttributes(
                list(map(lambda x : QgsField('{}_cont'.format(x), QVariant.Int),
                list(self.aquifer_lim.keys())))
                ))

            assert(aquifer_vor_cliped_.dataProvider().addAttributes(
                [QgsField('isContaminated',QVariant.Int)]
            ))

            with edit(aquifer_vor_cliped_):
                for f in aquifer_vor_cliped_.getFeatures():
                    f['isContaminated'] = 0
                    for ke in self.aquifer_lim:
                        if float(f[ke]) > self.aquifer_lim[ke]:
                            f['{}_cont'.format(ke)] = 1
                            f['isContaminated'] = 1
                        else:
                            f['{}_cont'.format(ke)] = 0
                        aquifer_vor_cliped_.updateFeature(f)
        self.aquifer_vor_cliped = aquifer_vor_cliped_
        # set_fill_color(self.aquifer_vor_cliped)
        # QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)
        ###########################################################
        #QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)


        
        _log_msg = "Success {} layer loader.".format(self.dlg.filename_aquifer_csv)
        iface.messageBar().pushMessage("ADREM INFO ", 
            _log_msg,
            level=Qgis.Info)

    # def _show_aquifer(self):
    #     QgsProject.instance().addMapLayer(self.aquifer_loc_layer)

    def do_the_math(self):
        allegato_f = Allegato_first()
        allegato_s = Allegato_second()
        if self.dlg.filename_shallow_csv:
            self.shallow_lim_ind = {}
            self.shallow_lim_res = {}
            for each in self.dlg.shallow_combo:
                try:
                    self.shallow_lim_ind[each] = float(allegato_f._get_lim_ind(each))
                    self.shallow_lim_res[each] = float(allegato_f._get_lim_res(each))
                except KeyError:
                    continue
            if not self.shallow_lim_ind or not self.shallow_lim_res:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_shallow_csv)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
        if self.dlg.filename_deep_csv:
            self.deep_lim_ind = {}
            self.deep_lim_res = {}
            for each in self.dlg.deep_combo:
                try:
                    self.deep_lim_ind[each] = float(allegato_f._get_lim_ind(each))
                    self.deep_lim_res[each] = float(allegato_f._get_lim_res(each))
                except KeyError:
                    continue
            if not self.deep_lim_ind or not self.deep_lim_res:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_deep_csv)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
        if self.dlg.filename_aquifer_csv:
            self.aquifer_lim = {}
            for each in self.dlg.aquifer_combo:
                try:
                    self.aquifer_lim[each] = float(allegato_s._get_lim(each))
                except KeyError:
                    continue
            if not self.aquifer_lim:
                msg = 'Please verify the field at : {}'.format(self.dlg.filename_aquifer_csv)
                iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                raise Exception(msg)
        
    def _analysis(self):
        try:
            if self.sha_vor_ind_cliped:
                with edit(self.sha_vor_ind_cliped):
                    for f in self.sha_vor_ind_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            
                            buff = f.geometry().buffer(10,2)
                            clean_pol = 0
                            polluted = 0
                            for g in self.sha_vor_ind_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            clean_pol = clean_pol + 1
                                        else:
                                            polluted = polluted + 1

                            half = math.floor((polluted + clean_pol)/2)
                            if (polluted > half):
                                f['isContaminated'] = 1
                            else:
                                f['isContaminated'] = 0

                            self.sha_vor_ind_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.sha_vor_ind_cliped)
                QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
        except (AttributeError, RuntimeError):
            pass
        
        try:
            if self.sha_vor_res_cliped:
                with edit(self.sha_vor_res_cliped):
                    for f in self.sha_vor_res_cliped.getFeatures():
                        if f['isContaminated'] == 0:
    
                            buff = f.geometry().buffer(10,2)
                            clean_pol = 0
                            polluted = 0
                            for g in self.sha_vor_res_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            clean_pol = clean_pol + 1
                                        else:
                                            polluted = polluted + 1

                            half = math.floor((polluted + clean_pol)/2)
                            if (polluted > half):
                                f['isContaminated'] = 1
                            else:
                                f['isContaminated'] = 0

                            self.sha_vor_res_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.sha_vor_res_cliped)
                QgsProject.instance().addMapLayer(self.sha_vor_res_cliped)
        except (AttributeError, RuntimeError):
            pass

        try:
            if self.deep_vor_res_cliped:
                with edit(self.deep_vor_res_cliped):
                    for f in self.deep_vor_res_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                        
                            buff = f.geometry().buffer(10,2)
                            clean_pol = 0
                            polluted = 0
                            for g in self.deep_vor_res_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            clean_pol = clean_pol + 1
                                        else:
                                            polluted = polluted + 1

                            half = math.floor((polluted + clean_pol)/2)
                            if (polluted > half):
                                f['isContaminated'] = 1
                            else:
                                f['isContaminated'] = 0

                            self.deep_vor_res_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.deep_vor_res_cliped)
                QgsProject.instance().addMapLayer(self.deep_vor_res_cliped)
        except (AttributeError, RuntimeError):
            pass
        
        try:
            if self.deep_vor_ind_cliped:
                with edit(self.deep_vor_ind_cliped):
                    for f in self.deep_vor_ind_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            
                            buff = f.geometry().buffer(10,2)
                            clean_pol = 0
                            polluted = 0
                            for g in self.deep_vor_ind_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            clean_pol = clean_pol + 1
                                        else:
                                            polluted = polluted + 1

                            half = math.floor((polluted + clean_pol)/2)
                            if (polluted > half):
                                f['isContaminated'] = 1
                            else:
                                f['isContaminated'] = 0

                            self.deep_vor_ind_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.deep_vor_ind_cliped)
                QgsProject.instance().addMapLayer(self.deep_vor_ind_cliped)
        except (AttributeError, RuntimeError):
            pass

        try:
            if self.aquifer_vor_cliped:
                with edit(self.aquifer_vor_cliped):
                    for f in self.aquifer_vor_cliped.getFeatures():
                        if f['isContaminated'] == 0:
                            
                            buff = f.geometry().buffer(10,2)
                            clean_pol = 0
                            polluted = 0
                            for g in self.aquifer_vor_cliped.getFeatures():
                                if f['fid'] != g['fid']:
                                    if g.geometry().intersects(buff):
                                        #iface.messageBar().pushMessage("Debug: ","we got inside",level=Qgis.Info)
                                        if g['isContaminated'] == 0:
                                            clean_pol = clean_pol + 1
                                        else:
                                            polluted = polluted + 1

                            half = math.floor((polluted + clean_pol)/2)
                            if (polluted > half):
                                f['isContaminated'] = 1
                            else:
                                f['isContaminated'] = 0

                            self.aquifer_vor_cliped.updateFeature(f)
                                            
            
                reCatLayer(self.aquifer_vor_cliped)
                QgsProject.instance().addMapLayer(self.aquifer_vor_cliped)
        except (AttributeError, RuntimeError):
            pass

    
    def _mergeNdOutput(self):
        root = QgsProject.instance().layerTreeRoot()
        group_output = root.addGroup('Output')
        group_to_be_remediate = root.addGroup('To be remediate')

        try:
            if self.sha_vor_ind_cliped:
                list_contaminats = []
                for f in self.sha_vor_ind_cliped.getFeatures():
                    if f['isContaminated'] == 1:
                        for ke in self.shallow_lim_ind:
                            if f['{}_cont'.format(ke)] == 1:
                                list_contaminats.append(ke)
                list_contaminats = list(set(list_contaminats))
                #QgsMessageLog.logMessage("{}".format(list_contaminats), 'ADREMTOOL', level=Qgis.Info)
                layer_modif = self.sha_vor_ind_cliped

                if len(list_contaminats)!= 0:

                    ###############################################################
                    param_disolve = {
                    'INPUT' : layer_modif,
                    'FIELD' : ['isContaminated'],
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
            
                    res = processing.run("native:dissolve", param_disolve)
                    tmp_layer_0 = res['OUTPUT']
                    #reCatLayer(tmp_layer)
                    #QgsProject.instance().addMapLayer(tmp_layer)
                    
                    param_multipart = {
                        'INPUT' : tmp_layer_0,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                    res_1 = processing.run('qgis:multiparttosingleparts',param_multipart)

                    tmp_layer = res_1['OUTPUT']
                    #QgsProject.instance().addMapLayer(tmp_layer)


                    ###############################################################

                    out_file = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_ind.shp')
                    
                    crs = QgsProject.instance().crs()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                    transform_context = QgsProject.instance().transformContext()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"

                    layerFields = QgsFields()
                    layerFields.append(QgsField('source',QVariant.Int))
                    #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                    for at in list_contaminats:
                       
                        layerFields.append(QgsField(at,QVariant.String))
                    #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                    #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                    ########### there is a bug here that shorten the fields names, I dont know how to solve it
                    field_names = layerFields.names()
                    ###########################################################
                    writer = QgsVectorFileWriter.create(
                                out_file,
                                layerFields,
                                QgsWkbTypes.Polygon,
                                crs,
                                transform_context,
                                save_options
                            )
                            
                    if writer.hasError() != QgsVectorFileWriter.NoError:
                        msg = 'writting output for sha_ind : {}'.format(writer.errorMessage())
                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                        raise Exception(msg)
            
                    # iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)
                    
                    ################################################
                    list_sources = dict()
                    ################################################

                    index = 1
                    for feat_dis in tmp_layer.getFeatures():
                        if feat_dis['isContaminated'] == 1:
                            tmp_dict = dict()
                            for each_c in list_contaminats:
                                tmp_dict[each_c] = float(0.0)

                            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
                            for f in self.sha_vor_ind_cliped.getFeatures():
                                if feat_dis.geometry().contains(f.geometry()):
                                    for each_c in list(list_contaminats):
                                        if tmp_dict[each_c] < float(f[each_c]):
                                            tmp_dict[each_c] = float(f[each_c])
                            
                            fet = QgsFeature()
                            fet.setGeometry(feat_dis.geometry())
                            new_list = [index]
                            #QgsMessageLog.logMessage("{}".format(tmp_dict), 'ADREMTOOL', level=Qgis.Info)
                            for key in list_contaminats:
                                new_list.append('{}'.format(tmp_dict[key]))
                            #QgsMessageLog.logMessage("{}".format(new_list), 'ADREMTOOL', level=Qgis.Info) 
                            fet.setAttributes(new_list)

                            list_sources["source_of_id_{}".format(index)] = index

                            index = index + 1
                            
                            
                            writer.addFeature(fet)
                            # iface.messageBar().pushMessage("Debug: ","write",level=Qgis.Info)

                            

                    del writer
                    out_sha_pol_ind = QgsVectorLayer(out_file, 'shallow_polluted_on_ind', 'ogr')
                    if out_sha_pol_ind.isValid():
                        set_fill_color(out_sha_pol_ind)
                        # out_sha_pol_ind.setCustomProperty("labeling", "pal")
                        # out_sha_pol_ind.setCustomProperty("labeling/enabled", "true")
                        # out_sha_pol_ind.setCustomProperty("labeling/fontFamily", "Arial")
                        # out_sha_pol_ind.setCustomProperty("labeling/fontSize", "12")
                        # out_sha_pol_ind.setCustomProperty("labeling/isExpression", True)
                        # out_sha_pol_ind.setCustomProperty("labeling/fieldName", "source")
                        # out_sha_pol_ind.setCustomProperty("labeling/placement", "2")
                        QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                        group_output.addLayer(out_sha_pol_ind)
                        
                  

                    #### select polygons
                    dialog_sha_ind = SelectSourceDialog()
                    dialog_sha_ind.setWindowTitle("Shallow : Ind")
                    dialog_sha_ind.listView.setSelectionMode(2)
                    model = QStandardItemModel()
                    for each_item in list_sources:
                        item = QStandardItem(each_item)
                        #item.setCheckable(True)
                        model.appendRow(item)

                    dialog_sha_ind.listView.setModel(model)
                    dialog_sha_ind.show()
                    ok = dialog_sha_ind.exec_()
                    if ok:
                        selected = dialog_sha_ind.listView.selectedIndexes()
                        
                        selids = []
                        for sid in selected:
                            selids.append(sid.data())
                        #QgsMessageLog.logMessage("{}".format(selids), 'ADREMTOOL', level=Qgis.Info)
                        if len(selids)!= 0:
                            out_sha_pol_ind.selectAll()
                            cloned_ = processing.run("native:saveselectedfeatures",
                                {'INPUT': out_sha_pol_ind, 'OUTPUT': 'memory:'})['OUTPUT']
                            out_sha_pol_ind.removeSelection()
                            cloned_.setName("sha_ind_to_be_remediate")
                            
                            dfeats = []
                            for feat in cloned_.getFeatures():
                                # QgsMessageLog.logMessage("{}".format(feat), 'ADREMTOOL', level=Qgis.Info)
                                if feat['source'] not in list(map(lambda x: list_sources[x],selids)):
                                    dfeats.append(feat['source'])
                            #QgsMessageLog.logMessage("{}".format(dfeats), 'ADREMTOOL', level=Qgis.Info)
                           

                            

                            caps = cloned_.dataProvider().capabilities()
                            if caps & QgsVectorDataProvider.DeleteAttributes:
                                res = cloned_.dataProvider().deleteFeatures(dfeats)
                                if res:
                                    fi_ = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_ind_to_be_remediate.shp')
                                    error = QgsVectorFileWriter.writeAsVectorFormatV2(
                                                cloned_,
                                                fi_,
                                                transform_context,
                                                save_options)
                                    if error[0] != QgsVectorFileWriter.NoError:
                                        msg = 'Error on writting output to : {}'.format(fi_)
                                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                        raise Exception(msg)

                                    set_fill_color(cloned_)
                                    QgsProject.instance().addMapLayer(cloned_, False)
                                    group_to_be_remediate.addLayer(cloned_)

                                    ##############################################################################################

                                    # tmp_sha_toberemediate_ind = QgsVectorLayer(fi_, 'tmp_sha_toberemediate_ind', 'ogr')

                                    # tmp_attr = []
                                    # for feat in tmp_sha_toberemediate_ind.fields():
                                    #     if feat.name() != 'source':
                                    #         tmp_attr.append(feat.name())
                                    #QgsMessageLog.logMessage("{}".format(tmp_attr), 'ADREMTOOL', level=Qgis.Info)
                                    
                                    tmp_tech = dict()
                                    for nm in field_names:
                                        if nm != 'source':
                                            gp_name = self.gpname.getGroupeName(nm)
                                            techlsit = self.matrixtech.getTechAASoil(gp_name)
                                            tmp_tech[nm] = techlsit
                                    #QgsMessageLog.logMessage("{}".format(tmp_tech), 'ADREMTOOL', level=Qgis.Info)

                                    ###############################################################
                                    ######################## MATRIx ###############################
                                    ###############################################################

                                    for cont_name in tmp_tech:
                                        out_file = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_ind_' + cont_name+ '_AA.shp')
                                    
                                        # crs = QgsProject.instance().crs()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                                        # transform_context = QgsProject.instance().transformContext()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                                        # save_options = QgsVectorFileWriter.SaveVectorOptions()
                                        # save_options.driverName = "ESRI Shapefile"
                                        # save_options.fileEncoding = "UTF-8"

                                        layerFields = QgsFields()
                                        layerFields.append(QgsField('AA',QVariant.String,'string',50.0))
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                                        # for at in list_contaminats:
                                        
                                        #     layerFields.append(QgsField(at,QVariant.String))
                                        # #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                                        # ########### there is a bug here that shorten the fields names, I dont know how to solve it
                                        # field_names = layerFields.names()
                                        ###########################################################
                                        writer = QgsVectorFileWriter.create(
                                                    out_file,
                                                    layerFields,
                                                    QgsWkbTypes.Point,
                                                    crs,
                                                    transform_context,
                                                    save_options

                                                )
                                                
                                        if writer.hasError() != QgsVectorFileWriter.NoError:
                                            msg = 'writting no geometry AA sha_ind : {}'.format(writer.errorMessage())
                                            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                            raise Exception(msg)
                                
                                        

                                        for tech in tmp_tech[cont_name]:
                                            fet = QgsFeature()
                                            fet.setAttributes([tech])
                                            writer.addFeature(fet)

                                                

                                        del writer
                                        out_sha_pol_ind = QgsVectorLayer(out_file, 'shallow_polluted_on_ind_' + cont_name+ '_AA', 'ogr')
                                        if out_sha_pol_ind.isValid():
                                            QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                                            group_to_be_remediate.addLayer(out_sha_pol_ind)
                                                            
                                                    
                                    


        except AttributeError:
            pass

        try:
            if self.sha_vor_res_cliped:
                list_contaminats = []
                for f in self.sha_vor_res_cliped.getFeatures():
                    if f['isContaminated'] == 1:
                        for ke in self.shallow_lim_res:
                            if f['{}_cont'.format(ke)] == 1:
                                list_contaminats.append(ke)
                list_contaminats = list(set(list_contaminats))
                
                layer_modif = self.sha_vor_res_cliped

                if len(list_contaminats)!= 0:
                    ###############################################################
                    param_disolve = {
                    'INPUT' : layer_modif,
                    'FIELD' : ['isContaminated'],
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
            
                    res = processing.run("native:dissolve", param_disolve)
                    tmp_layer_0 = res['OUTPUT']
                    #reCatLayer(tmp_layer)
                    #QgsProject.instance().addMapLayer(tmp_layer)
                    
                    param_multipart = {
                        'INPUT' : tmp_layer_0,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                    res_1 = processing.run('qgis:multiparttosingleparts',param_multipart)

                    tmp_layer = res_1['OUTPUT']
                    #QgsProject.instance().addMapLayer(tmp_layer)


                    ###############################################################



                    out_file = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_res.shp')
                    
                    crs = QgsProject.instance().crs()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                    transform_context = QgsProject.instance().transformContext()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"

                    layerFields = QgsFields()
                    layerFields.append(QgsField('source',QVariant.Int))
                    #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                    for at in list_contaminats:
                        layerFields.append(QgsField(at, QVariant.String))

                    field_names = layerFields.names()                    
                    #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)
                    writer = QgsVectorFileWriter.create(
                                out_file,
                                layerFields,
                                QgsWkbTypes.Polygon,
                                crs,
                                transform_context,
                                save_options
                            )
                  
                    if writer.hasError() != QgsVectorFileWriter.NoError:
                        msg = 'writting output for sha_ind : {}'.format(writer.errorMessage())
                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                        raise Exception(msg)
            
                    ################################################
                    list_sources = dict()
                    ################################################

                    index = 1
                    for feat_dis in tmp_layer.getFeatures():
                        if feat_dis['isContaminated'] == 1:
                            tmp_dict = dict()
                            for each_c in list_contaminats:
                                tmp_dict[each_c] = float(0.0)

                            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
                            for f in self.sha_vor_res_cliped.getFeatures():
                                if feat_dis.geometry().contains(f.geometry()):
                                    for each_c in list(list_contaminats):
                                        if tmp_dict[each_c] < float(f[each_c]):
                                            tmp_dict[each_c] = float(f[each_c])
                            
                            fet = QgsFeature()
                            fet.setGeometry(feat_dis.geometry())
                            new_list = [index]
                            #QgsMessageLog.logMessage("{}".format(tmp_dict), 'ADREMTOOL', level=Qgis.Info)
                            for key in list_contaminats:
                                new_list.append('{}'.format(tmp_dict[key]))
                            #QgsMessageLog.logMessage("{}".format(new_list), 'ADREMTOOL', level=Qgis.Info) 
                            fet.setAttributes(new_list)

                            list_sources["source_of_id_{}".format(index)] = index

                            index = index + 1
                            
                            
                            writer.addFeature(fet)
                            # iface.messageBar().pushMessage("Debug: ","write",level=Qgis.Info)

                    del writer

                    out_sha_pol_res = QgsVectorLayer(out_file, 'shallow_polluted_on_res', 'ogr')
                    if out_sha_pol_res.isValid():
                        set_fill_color(out_sha_pol_res)
                        QgsProject.instance().addMapLayer(out_sha_pol_res, False)
                        group_output.addLayer(out_sha_pol_res)

                    #### select polygons
                    dialog_sha_res = SelectSourceDialog()
                    dialog_sha_res.setWindowTitle("Shallow : Res")
                    dialog_sha_res.listView.setSelectionMode(2)
                    model = QStandardItemModel()
                    for each_item in list_sources:
                        model.appendRow(QStandardItem(each_item))

                    dialog_sha_res.listView.setModel(model)
                    dialog_sha_res.show()
                    ok = dialog_sha_res.exec_()
                    if ok:
                        selected = dialog_sha_res.listView.selectedIndexes()
                        
                        selids = []
                        for sid in selected:
                            selids.append(sid.data())
                        #QgsMessageLog.logMessage("{}".format(selids), 'ADREMTOOL', level=Qgis.Info)
                        if len(selids)!= 0:
                            out_sha_pol_res.selectAll()
                            cloned_ = processing.run("native:saveselectedfeatures",
                                {'INPUT': out_sha_pol_res, 'OUTPUT': 'memory:'})['OUTPUT']
                            out_sha_pol_res.removeSelection()
                            cloned_.setName("sha_res_to_be_remediate")
                            
                            dfeats = []
                            for feat in cloned_.getFeatures():
                                if feat['source'] not in list(map(lambda x: list_sources[x],selids)):
                                    dfeats.append(feat['source'])

                            caps = cloned_.dataProvider().capabilities()
                            if caps & QgsVectorDataProvider.DeleteAttributes:
                                res = cloned_.dataProvider().deleteFeatures(dfeats)
                                if res:
                                    fi_ = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_res_to_be_remediate.shp')
                                    error = QgsVectorFileWriter.writeAsVectorFormatV2(
                                                cloned_,
                                                fi_,
                                                transform_context,
                                                save_options)
                                    if error[0] != QgsVectorFileWriter.NoError:
                                        msg = 'Error on writting output to : {}'.format(fi_)
                                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                        raise Exception(msg)
                                    
                                    set_fill_color(cloned_)
                                    QgsProject.instance().addMapLayer(cloned_, False)
                                    group_to_be_remediate.addLayer(cloned_)


                                    ##############################################################################################

                                    # tmp_sha_toberemediate_ind = QgsVectorLayer(fi_, 'tmp_sha_toberemediate_ind', 'ogr')

                                    # tmp_attr = []
                                    # for feat in tmp_sha_toberemediate_ind.fields():
                                    #     if feat.name() != 'source':
                                    #         tmp_attr.append(feat.name())
                                    #QgsMessageLog.logMessage("{}".format(tmp_attr), 'ADREMTOOL', level=Qgis.Info)
                                    
                                    tmp_tech = dict()
                                    for nm in field_names:
                                        if nm != 'source':
                                            gp_name = self.gpname.getGroupeName(nm)
                                            techlsit = self.matrixtech.getTechAASoil(gp_name)
                                            tmp_tech[nm] = techlsit
                                    #QgsMessageLog.logMessage("{}".format(tmp_tech), 'ADREMTOOL', level=Qgis.Info)

                                    ###############################################################
                                    ######################## MATRIx ###############################
                                    ###############################################################

                                    for cont_name in tmp_tech:
                                        out_file = os.path.join(self.dlg.outputDir.text(), 'shallow_polluted_on_res_' + cont_name+ '_AA.shp')
                                    
                                        # crs = QgsProject.instance().crs()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                                        # transform_context = QgsProject.instance().transformContext()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                                        # save_options = QgsVectorFileWriter.SaveVectorOptions()
                                        # save_options.driverName = "ESRI Shapefile"
                                        # save_options.fileEncoding = "UTF-8"

                                        layerFields = QgsFields()
                                        layerFields.append(QgsField('AA',QVariant.String,'string',50.0))
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                                        # for at in list_contaminats:
                                        
                                        #     layerFields.append(QgsField(at,QVariant.String))
                                        # #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                                        # ########### there is a bug here that shorten the fields names, I dont know how to solve it
                                        # field_names = layerFields.names()
                                        ###########################################################
                                        writer = QgsVectorFileWriter.create(
                                                    out_file,
                                                    layerFields,
                                                    QgsWkbTypes.Point,
                                                    crs,
                                                    transform_context,
                                                    save_options

                                                )
                                                
                                        if writer.hasError() != QgsVectorFileWriter.NoError:
                                            msg = 'writting no geometry AA on shallow on res : {}'.format(writer.errorMessage())
                                            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                            raise Exception(msg)
                                
                                        

                                        for tech in tmp_tech[cont_name]:
                                            fet = QgsFeature()
                                            fet.setAttributes([tech])
                                            writer.addFeature(fet)

                                                

                                        del writer
                                        out_sha_pol_ind = QgsVectorLayer(out_file, 'shallow_polluted_on_res_' + cont_name+ '_AA', 'ogr')
                                        if out_sha_pol_ind.isValid():
                                            QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                                            group_to_be_remediate.addLayer(out_sha_pol_ind)

                    

        except AttributeError:
            pass

        try:
            if self.deep_vor_res_cliped:
                list_contaminats = []
                for f in self.deep_vor_res_cliped.getFeatures():
                    if f['isContaminated'] == 1:
                        for ke in self.deep_lim_res:
                            if f['{}_cont'.format(ke)] == 1:
                                list_contaminats.append(ke)
                list_contaminats = list(set(list_contaminats))
                
                layer_modif = self.deep_vor_res_cliped

                if len(list_contaminats)!= 0:
                    ###############################################################
                    param_disolve = {
                    'INPUT' : layer_modif,
                    'FIELD' : ['isContaminated'],
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
            
                    res = processing.run("native:dissolve", param_disolve)
                    tmp_layer_0 = res['OUTPUT']
                    #reCatLayer(tmp_layer)
                    #QgsProject.instance().addMapLayer(tmp_layer)
                    
                    param_multipart = {
                        'INPUT' : tmp_layer_0,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                    res_1 = processing.run('qgis:multiparttosingleparts',param_multipart)

                    tmp_layer = res_1['OUTPUT']
                    #QgsProject.instance().addMapLayer(tmp_layer)


                    ###############################################################



                    out_file = os.path.join(self.dlg.outputDir.text(), 'deep_soil_polluted_on_res.shp')
                    
                    crs = QgsProject.instance().crs()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                    transform_context = QgsProject.instance().transformContext()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"

                    layerFields = QgsFields()
                    layerFields.append(QgsField('source',QVariant.Int))
                    #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                    for at in list_contaminats:
                        layerFields.append(QgsField(at, QVariant.String))

                    field_names = layerFields.names()

                    #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)
                    writer = QgsVectorFileWriter.create(
                                out_file,
                                layerFields,
                                QgsWkbTypes.Polygon,
                                crs,
                                transform_context,
                                save_options
                            )
                            # iface.messageBar().pushMessage("Debug: ","fuck here",level=Qgis.Info)
                    if writer.hasError() != QgsVectorFileWriter.NoError:
                        msg = 'writting output for sha_ind : {}'.format(writer.errorMessage())
                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                        raise Exception(msg)
                    
                    ################################################
                    list_sources = dict()
                    ################################################

                    index = 1
                    for feat_dis in tmp_layer.getFeatures():
                        if feat_dis['isContaminated'] == 1:
                            tmp_dict = dict()
                            for each_c in list_contaminats:
                                tmp_dict[each_c] = float(0.0)

                            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
                            for f in self.deep_vor_res_cliped.getFeatures():
                                if feat_dis.geometry().contains(f.geometry()):
                                    for each_c in list(list_contaminats):
                                        if tmp_dict[each_c] < float(f[each_c]):
                                            tmp_dict[each_c] = float(f[each_c])
                            
                            fet = QgsFeature()
                            fet.setGeometry(feat_dis.geometry())
                            new_list = [index]
                            #QgsMessageLog.logMessage("{}".format(tmp_dict), 'ADREMTOOL', level=Qgis.Info)
                            for key in list_contaminats:
                                new_list.append('{}'.format(tmp_dict[key]))
                            #QgsMessageLog.logMessage("{}".format(new_list), 'ADREMTOOL', level=Qgis.Info) 
                            fet.setAttributes(new_list)

                            list_sources["source_of_id_{}".format(index)] = index

                            index = index + 1
                            
                            
                            writer.addFeature(fet)
                            # iface.messageBar().pushMessage("Debug: ","write",level=Qgis.Info)

                    del writer

                    out_deep_pol_res = QgsVectorLayer(out_file, 'deep_soil_polluted_on_res', 'ogr')
                    if out_deep_pol_res.isValid():
                        set_fill_color(out_deep_pol_res)
                        QgsProject.instance().addMapLayer(out_deep_pol_res, False)
                        group_output.addLayer(out_deep_pol_res)

                    #### select polygons
                    dialog_deep_res = SelectSourceDialog()
                    dialog_deep_res.setWindowTitle("Deep soil : Res")
                    dialog_deep_res.listView.setSelectionMode(2)
                    model = QStandardItemModel()
                    for each_item in list_sources:
                        model.appendRow(QStandardItem(each_item))

                    dialog_deep_res.listView.setModel(model)
                    dialog_deep_res.show()
                    ok = dialog_deep_res.exec_()
                    if ok:
                        selected = dialog_deep_res.listView.selectedIndexes()
                        
                        selids = []
                        for sid in selected:
                            selids.append(sid.data())
                        #QgsMessageLog.logMessage("{}".format(selids), 'ADREMTOOL', level=Qgis.Info)
                        if len(selids)!= 0:
                            out_deep_pol_res.selectAll()
                            cloned_ = processing.run("native:saveselectedfeatures",
                                {'INPUT': out_deep_pol_res, 'OUTPUT': 'memory:'})['OUTPUT']
                            out_deep_pol_res.removeSelection()
                            cloned_.setName("deep_res_to_be_remediate")
                            
                            dfeats = []
                            for feat in cloned_.getFeatures():
                                if feat['source'] not in list(map(lambda x: list_sources[x],selids)):
                                    dfeats.append(feat['source'])

                            caps = cloned_.dataProvider().capabilities()
                            if caps & QgsVectorDataProvider.DeleteAttributes:
                                res = cloned_.dataProvider().deleteFeatures(dfeats)
                                if res:
                                    fi_ = os.path.join(self.dlg.outputDir.text(), 'deep_soil_polluted_on_res_to_be_remediate.shp')
                                    error = QgsVectorFileWriter.writeAsVectorFormatV2(
                                                cloned_,
                                                fi_,
                                                transform_context,
                                                save_options)
                                    if error[0] != QgsVectorFileWriter.NoError:
                                        msg = 'Error on writting output to : {}'.format(fi_)
                                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                        raise Exception(msg)
                                    
                                    set_fill_color(cloned_)
                                    QgsProject.instance().addMapLayer(cloned_, False)
                                    group_to_be_remediate.addLayer(cloned_)

                                    #############################################################################################

                                    # tmp_sha_toberemediate_ind = QgsVectorLayer(fi_, 'tmp_sha_toberemediate_ind', 'ogr')

                                    # tmp_attr = []
                                    # for feat in tmp_sha_toberemediate_ind.fields():
                                    #     if feat.name() != 'source':
                                    #         tmp_attr.append(feat.name())
                                    #QgsMessageLog.logMessage("{}".format(tmp_attr), 'ADREMTOOL', level=Qgis.Info)
                                    
                                    tmp_tech = dict()
                                    for nm in field_names:
                                        if nm != 'source':
                                            gp_name = self.gpname.getGroupeName(nm)
                                            techlsit = self.matrixtech.getTechAASoil(gp_name)
                                            tmp_tech[nm] = techlsit
                                    #QgsMessageLog.logMessage("{}".format(tmp_tech), 'ADREMTOOL', level=Qgis.Info)

                                    ###############################################################
                                    ######################## MATRIx ###############################
                                    ###############################################################

                                    for cont_name in tmp_tech:
                                        out_file = os.path.join(self.dlg.outputDir.text(),'deep_soil_polluted_on_res_' + cont_name+ '_AA.shp')
                                    
                                        # crs = QgsProject.instance().crs()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                                        # transform_context = QgsProject.instance().transformContext()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                                        # save_options = QgsVectorFileWriter.SaveVectorOptions()
                                        # save_options.driverName = "ESRI Shapefile"
                                        # save_options.fileEncoding = "UTF-8"

                                        layerFields = QgsFields()
                                        layerFields.append(QgsField('AA',QVariant.String,'string',50.0))
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                                        # for at in list_contaminats:
                                        
                                        #     layerFields.append(QgsField(at,QVariant.String))
                                        # #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                                        # ########### there is a bug here that shorten the fields names, I dont know how to solve it
                                        # field_names = layerFields.names()
                                        ###########################################################
                                        writer = QgsVectorFileWriter.create(
                                                    out_file,
                                                    layerFields,
                                                    QgsWkbTypes.Point,
                                                    crs,
                                                    transform_context,
                                                    save_options

                                                )
                                                
                                        if writer.hasError() != QgsVectorFileWriter.NoError:
                                            msg = 'writting no geometry AA deep on res : {}'.format(writer.errorMessage())
                                            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                            raise Exception(msg)
                                
                                        

                                        for tech in tmp_tech[cont_name]:
                                            fet = QgsFeature()
                                            fet.setAttributes([tech])
                                            writer.addFeature(fet)

                                                

                                        del writer
                                        out_sha_pol_ind = QgsVectorLayer(out_file, 'deep_soil_polluted_on_res_' + cont_name+ '_AA', 'ogr')
                                        if out_sha_pol_ind.isValid():
                                            QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                                            group_to_be_remediate.addLayer(out_sha_pol_ind)


        except AttributeError:
            pass

        try:
            if self.deep_vor_ind_cliped:
                list_contaminats = []
                for f in self.deep_vor_ind_cliped.getFeatures():
                    if f['isContaminated'] == 1:
                        for ke in self.deep_lim_ind:
                            if f['{}_cont'.format(ke)] == 1:
                                list_contaminats.append(ke)
                list_contaminats = list(set(list_contaminats))
                
                layer_modif = self.deep_vor_ind_cliped

                if len(list_contaminats)!= 0:
                    ###############################################################
                    param_disolve = {
                    'INPUT' : layer_modif,
                    'FIELD' : ['isContaminated'],
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
            
                    res = processing.run("native:dissolve", param_disolve)
                    tmp_layer_0 = res['OUTPUT']
                    #reCatLayer(tmp_layer)
                    #QgsProject.instance().addMapLayer(tmp_layer)
                    
                    param_multipart = {
                        'INPUT' : tmp_layer_0,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                    res_1 = processing.run('qgis:multiparttosingleparts',param_multipart)

                    tmp_layer = res_1['OUTPUT']
                    #QgsProject.instance().addMapLayer(tmp_layer)


                    ###############################################################

                    out_file = os.path.join(self.dlg.outputDir.text(), 'deep_soil_polluted_on_ind.shp')
                    
                    crs = QgsProject.instance().crs()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                    transform_context = QgsProject.instance().transformContext()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"

                    layerFields = QgsFields()
                    layerFields.append(QgsField('source',QVariant.Int))
                    #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                    for at in list_contaminats:
                        layerFields.append(QgsField(at, QVariant.String))

                    field_names = layerFields.names()
                    #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)
                    writer = QgsVectorFileWriter.create(
                                out_file,
                                layerFields,
                                QgsWkbTypes.Polygon,
                                crs,
                                transform_context,
                                save_options
                            )
                            # iface.messageBar().pushMessage("Debug: ","fuck here",level=Qgis.Info)
                    if writer.hasError() != QgsVectorFileWriter.NoError:
                        msg = 'writting output for sha_ind : {}'.format(writer.errorMessage())
                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                        raise Exception(msg)
            
                    ################################################
                    list_sources = dict()
                    ################################################

                    index = 1
                    for feat_dis in tmp_layer.getFeatures():
                        if feat_dis['isContaminated'] == 1:
                            tmp_dict = dict()
                            for each_c in list_contaminats:
                                tmp_dict[each_c] = float(0.0)

                            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
                            for f in self.deep_vor_ind_cliped.getFeatures():
                                if feat_dis.geometry().contains(f.geometry()):
                                    for each_c in list(list_contaminats):
                                        if tmp_dict[each_c] < float(f[each_c]):
                                            tmp_dict[each_c] = float(f[each_c])
                            
                            fet = QgsFeature()
                            fet.setGeometry(feat_dis.geometry())
                            new_list = [index]
                            #QgsMessageLog.logMessage("{}".format(tmp_dict), 'ADREMTOOL', level=Qgis.Info)
                            for key in list_contaminats:
                                new_list.append('{}'.format(tmp_dict[key]))
                            #QgsMessageLog.logMessage("{}".format(new_list), 'ADREMTOOL', level=Qgis.Info) 
                            fet.setAttributes(new_list)

                            list_sources["source_of_id_{}".format(index)] = index

                            index = index + 1
                            
                            
                            writer.addFeature(fet)
                            # iface.messageBar().pushMessage("Debug: ","write",level=Qgis.Info)

                    del writer

                    out_deep_pol_ind = QgsVectorLayer(out_file, 'deep_soil_polluted_on_ind', 'ogr')
                    if out_deep_pol_ind.isValid():
                        set_fill_color(out_deep_pol_ind)
                        QgsProject.instance().addMapLayer(out_deep_pol_ind, False)
                        group_output.addLayer(out_deep_pol_ind)

                    #### select polygons
                    dialog_deep_ind = SelectSourceDialog()
                    dialog_deep_ind.setWindowTitle("Deep soil : Ind")
                    dialog_deep_ind.listView.setSelectionMode(2)
                    model = QStandardItemModel()
                    for each_item in list_sources:
                        model.appendRow(QStandardItem(each_item))

                    dialog_deep_ind.listView.setModel(model)
                    dialog_deep_ind.show()
                    ok = dialog_deep_ind.exec_()
                    if ok:
                        selected = dialog_deep_ind.listView.selectedIndexes()
                        
                        selids = []
                        for sid in selected:
                            selids.append(sid.data())
                        #QgsMessageLog.logMessage("{}".format(selids), 'ADREMTOOL', level=Qgis.Info)
                        if len(selids)!= 0:
                            out_deep_pol_ind.selectAll()
                            cloned_ = processing.run("native:saveselectedfeatures",
                                {'INPUT': out_deep_pol_ind, 'OUTPUT': 'memory:'})['OUTPUT']
                            out_deep_pol_ind.removeSelection()
                            cloned_.setName("deep_ind_to_be_remediate")
                            
                            dfeats = []
                            for feat in cloned_.getFeatures():
                                if feat['source'] not in list(map(lambda x: list_sources[x],selids)):
                                    dfeats.append(feat['source'])

                            caps = cloned_.dataProvider().capabilities()
                            if caps & QgsVectorDataProvider.DeleteAttributes:
                                res = cloned_.dataProvider().deleteFeatures(dfeats)
                                if res:
                                    fi_ = os.path.join(self.dlg.outputDir.text(), 'deep_soil_polluted_on_ind_to_be_remediate.shp')
                                    error = QgsVectorFileWriter.writeAsVectorFormatV2(
                                                cloned_,
                                                fi_,
                                                transform_context,
                                                save_options)
                                    if error[0] != QgsVectorFileWriter.NoError:
                                        msg = 'Error on writting output to : {}'.format(fi_)
                                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                        raise Exception(msg)
                                    
                                    set_fill_color(cloned_)
                                    QgsProject.instance().addMapLayer(cloned_, False)
                                    group_to_be_remediate.addLayer(cloned_)

                                    #############################################################################################

                                    # tmp_sha_toberemediate_ind = QgsVectorLayer(fi_, 'tmp_sha_toberemediate_ind', 'ogr')

                                    # tmp_attr = []
                                    # for feat in tmp_sha_toberemediate_ind.fields():
                                    #     if feat.name() != 'source':
                                    #         tmp_attr.append(feat.name())
                                    #QgsMessageLog.logMessage("{}".format(tmp_attr), 'ADREMTOOL', level=Qgis.Info)
                                    
                                    tmp_tech = dict()
                                    for nm in field_names:
                                        if nm != 'source':
                                            gp_name = self.gpname.getGroupeName(nm)
                                            techlsit = self.matrixtech.getTechAASoil(gp_name)
                                            tmp_tech[nm] = techlsit
                                    #QgsMessageLog.logMessage("{}".format(tmp_tech), 'ADREMTOOL', level=Qgis.Info)

                                    ###############################################################
                                    ######################## MATRIx ###############################
                                    ###############################################################

                                    for cont_name in tmp_tech:
                                        out_file = os.path.join(self.dlg.outputDir.text(),'deep_soil_polluted_on_ind_' + cont_name+ '_AA.shp')
                                    
                                        # crs = QgsProject.instance().crs()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                                        # transform_context = QgsProject.instance().transformContext()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                                        # save_options = QgsVectorFileWriter.SaveVectorOptions()
                                        # save_options.driverName = "ESRI Shapefile"
                                        # save_options.fileEncoding = "UTF-8"

                                        layerFields = QgsFields()
                                        layerFields.append(QgsField('AA',QVariant.String,'string',50.0))
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                                        # for at in list_contaminats:
                                        
                                        #     layerFields.append(QgsField(at,QVariant.String))
                                        # #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                                        # ########### there is a bug here that shorten the fields names, I dont know how to solve it
                                        # field_names = layerFields.names()
                                        ###########################################################
                                        writer = QgsVectorFileWriter.create(
                                                    out_file,
                                                    layerFields,
                                                    QgsWkbTypes.Point,
                                                    crs,
                                                    transform_context,
                                                    save_options

                                                )
                                                
                                        if writer.hasError() != QgsVectorFileWriter.NoError:
                                            msg = 'writting no geometry AA deep soil on ind : {}'.format(writer.errorMessage())
                                            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                            raise Exception(msg)
                                
                                        

                                        for tech in tmp_tech[cont_name]:
                                            fet = QgsFeature()
                                            fet.setAttributes([tech])
                                            writer.addFeature(fet)

                                                

                                        del writer
                                        out_sha_pol_ind = QgsVectorLayer(out_file, 'deep_soil_polluted_on_ind_' + cont_name+ '_AA', 'ogr')
                                        if out_sha_pol_ind.isValid():
                                            QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                                            group_to_be_remediate.addLayer(out_sha_pol_ind)



        except AttributeError:
            pass

        try:
            if self.aquifer_vor_cliped:
                list_contaminats = []
                for f in self.aquifer_vor_cliped.getFeatures():
                    if f['isContaminated'] == 1:
                        for ke in self.aquifer_lim:
                            if f['{}_cont'.format(ke)] == 1:
                                list_contaminats.append(ke)
                list_contaminats = list(set(list_contaminats))
                
                layer_modif = self.aquifer_vor_cliped

                if len(list_contaminats)!= 0:
                    ###############################################################
                    param_disolve = {
                    'INPUT' : layer_modif,
                    'FIELD' : ['isContaminated'],
                    'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
            
                    res = processing.run("native:dissolve", param_disolve)
                    tmp_layer_0 = res['OUTPUT']
                    #reCatLayer(tmp_layer)
                    #QgsProject.instance().addMapLayer(tmp_layer)
                    
                    param_multipart = {
                        'INPUT' : tmp_layer_0,
                        'OUTPUT' : 'TEMPORARY_OUTPUT'
                    }
                    res_1 = processing.run('qgis:multiparttosingleparts',param_multipart)

                    tmp_layer = res_1['OUTPUT']
                    #QgsProject.instance().addMapLayer(tmp_layer)


                    ###############################################################

                    out_file = os.path.join(self.dlg.outputDir.text(), 'aquifer_polluted.shp')
                    
                    crs = QgsProject.instance().crs()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                    transform_context = QgsProject.instance().transformContext()
                    # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                    save_options = QgsVectorFileWriter.SaveVectorOptions()
                    save_options.driverName = "ESRI Shapefile"
                    save_options.fileEncoding = "UTF-8"

                    layerFields = QgsFields()
                    layerFields.append(QgsField('source',QVariant.Int))
                    #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                    for at in list_contaminats:
                        layerFields.append(QgsField(at, QVariant.String))

                    field_names = layerFields.names()
                    #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)
                    writer = QgsVectorFileWriter.create(
                                out_file,
                                layerFields,
                                QgsWkbTypes.Polygon,
                                crs,
                                transform_context,
                                save_options
                            )
                            
                    if writer.hasError() != QgsVectorFileWriter.NoError:
                        msg = 'writting output for aquifer : {}'.format(writer.errorMessage())
                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                        raise Exception(msg)
            
                    ################################################
                    list_sources = dict()
                    ################################################
                    
                    index = 1
                    for feat_dis in tmp_layer.getFeatures():
                        if feat_dis['isContaminated'] == 1:
                            tmp_dict = dict()
                            for each_c in list_contaminats:
                                tmp_dict[each_c] = float(0.0)

                            #QgsProject.instance().addMapLayer(self.sha_vor_ind_cliped)
                            for f in self.aquifer_vor_cliped.getFeatures():
                                if feat_dis.geometry().contains(f.geometry()):
                                    for each_c in list(list_contaminats):
                                        if tmp_dict[each_c] < float(f[each_c]):
                                            tmp_dict[each_c] = float(f[each_c])
                            
                            fet = QgsFeature()
                            fet.setGeometry(feat_dis.geometry())
                            new_list = [index]
                            #QgsMessageLog.logMessage("{}".format(tmp_dict), 'ADREMTOOL', level=Qgis.Info)
                            for key in list_contaminats:
                                new_list.append('{}'.format(tmp_dict[key]))
                            #QgsMessageLog.logMessage("{}".format(new_list), 'ADREMTOOL', level=Qgis.Info) 
                            fet.setAttributes(new_list)

                            list_sources["source_of_id_{}".format(index)] = index

                            index = index + 1
                            
                            
                            writer.addFeature(fet)
                            # iface.messageBar().pushMessage("Debug: ","write",level=Qgis.Info)

                    del writer

                    #QgsMessageLog.logMessage(" we are here", 'ADREMTOOL', level=Qgis.Info)
                    out_aquifer_pol = QgsVectorLayer(out_file, 'aquifer_polluted', 'ogr')
                    if out_aquifer_pol.isValid():
                        set_fill_color(out_aquifer_pol)
                        QgsProject.instance().addMapLayer(out_aquifer_pol, False)
                        group_output.addLayer(out_aquifer_pol)

                    #### select polygons
                    dialog_aquifer = SelectSourceDialog()
                    # dialog_aquifer.title.setText("Aquifer")
                    dialog_aquifer.setWindowTitle("Aquifer")
                    dialog_aquifer.listView.setSelectionMode(2)
                    
                    model = QStandardItemModel()
                    for each_item in list_sources:
                        model.appendRow(QStandardItem(each_item))
                    dialog_aquifer.listView.setModel(model)
                    dialog_aquifer.show()
                    #QgsMessageLog.logMessage("Can we reach here", 'ADREMTOOL', level=Qgis.Info)
                    ok = dialog_aquifer.exec_()
                    if ok:
                        selected = dialog_aquifer.listView.selectedIndexes()
                        
                        selids = []
                        for sid in selected:
                            selids.append(sid.data())
                        #QgsMessageLog.logMessage("{}".format(selids), 'ADREMTOOL', level=Qgis.Info)
                        if len(selids)!= 0:
                            out_aquifer_pol.selectAll()
                            cloned_ = processing.run("native:saveselectedfeatures",
                                {'INPUT': out_aquifer_pol, 'OUTPUT': 'memory:'})['OUTPUT']
                            out_aquifer_pol.removeSelection()
                            cloned_.setName("aquifer_to_be_remediate")
                            
                            dfeats = []
                            for feat in cloned_.getFeatures():
                                if feat['source'] not in list(map(lambda x: list_sources[x],selids)):
                                    dfeats.append(feat['source'])

                            caps = cloned_.dataProvider().capabilities()
                            if caps & QgsVectorDataProvider.DeleteAttributes:
                                res = cloned_.dataProvider().deleteFeatures(dfeats)
                                if res:
                                    fi_ = os.path.join(self.dlg.outputDir.text(), 'aquifer_polluted_to_be_remediate.shp')
                                    error = QgsVectorFileWriter.writeAsVectorFormatV2(
                                                cloned_,
                                                fi_,
                                                transform_context,
                                                save_options)
                                    if error[0] != QgsVectorFileWriter.NoError:
                                        msg = 'Error on writting output to : {}'.format(fi_)
                                        iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                        raise Exception(msg)
                                    
                                    set_fill_color(cloned_)
                                    QgsProject.instance().addMapLayer(cloned_, False)
                                    group_to_be_remediate.addLayer(cloned_)

                                    #############################################################################################

                                    # tmp_sha_toberemediate_ind = QgsVectorLayer(fi_, 'tmp_sha_toberemediate_ind', 'ogr')

                                    # tmp_attr = []
                                    # for feat in tmp_sha_toberemediate_ind.fields():
                                    #     if feat.name() != 'source':
                                    #         tmp_attr.append(feat.name())
                                    #QgsMessageLog.logMessage("{}".format(tmp_attr), 'ADREMTOOL', level=Qgis.Info)
                                    
                                    tmp_tech = dict()
                                    for nm in field_names:
                                        if nm != 'source':
                                            gp_name = self.gpname.getGroupeName(nm)
                                            techlsit = self.matrixtech.getTechAAGroudwater(gp_name)
                                            tmp_tech[nm] = techlsit
                                    #QgsMessageLog.logMessage("{}".format(tmp_tech), 'ADREMTOOL', level=Qgis.Info)

                                    ###############################################################
                                    ######################## MATRIx ###############################
                                    ###############################################################

                                    for cont_name in tmp_tech:
                                        out_file = os.path.join(self.dlg.outputDir.text(),'aquifer_polluted_' + cont_name+ '_AA.shp')
                                    
                                        # crs = QgsProject.instance().crs()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(crs),level=Qgis.Info)
                                        # transform_context = QgsProject.instance().transformContext()
                                        # # iface.messageBar().pushMessage("Debug: ","{}".format(transform_context),level=Qgis.Info)
                                        # save_options = QgsVectorFileWriter.SaveVectorOptions()
                                        # save_options.driverName = "ESRI Shapefile"
                                        # save_options.fileEncoding = "UTF-8"

                                        layerFields = QgsFields()
                                        layerFields.append(QgsField('AA',QVariant.String,'string',50.0))
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(layerFields),level=Qgis.Info)
                                        # for at in list_contaminats:
                                        
                                        #     layerFields.append(QgsField(at,QVariant.String))
                                        # #QgsMessageLog.logMessage("{}".format(layerFields.names()), 'ADREMTOOL', level=Qgis.Info)
                                        # #iface.messageBar().pushMessage("Debug: ","{}".format(out_file),level=Qgis.Info)

                                        # ########### there is a bug here that shorten the fields names, I dont know how to solve it
                                        # field_names = layerFields.names()
                                        ###########################################################
                                        writer = QgsVectorFileWriter.create(
                                                    out_file,
                                                    layerFields,
                                                    QgsWkbTypes.Point,
                                                    crs,
                                                    transform_context,
                                                    save_options

                                                )
                                                
                                        if writer.hasError() != QgsVectorFileWriter.NoError:
                                            msg = 'writting no geometry AA aquifer : {}'.format(writer.errorMessage())
                                            iface.messageBar().pushMessage("ERROR", msg, level=Qgis.Critical)
                                            raise Exception(msg)
                                
                                        

                                        for tech in tmp_tech[cont_name]:
                                            fet = QgsFeature()
                                            fet.setAttributes([tech])
                                            writer.addFeature(fet)

                                                

                                        del writer
                                        out_sha_pol_ind = QgsVectorLayer(out_file, 'aquifer_polluted_' + cont_name+ '_AA', 'ogr')
                                        if out_sha_pol_ind.isValid():
                                            QgsProject.instance().addMapLayer(out_sha_pol_ind, False)
                                            group_to_be_remediate.addLayer(out_sha_pol_ind)


        except AttributeError:
            pass

    def _show_help(self):
        help_file = 'file:///{0}'.format(Path(os.path.join(os.path.dirname(__file__),'help/build/html/index.html')))
        QDesktopServices.openUrl(QUrl(help_file))

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ADREMToolDialog()
            #self.dialog_aquifer = SelectSourceDialog()

        # windows title
        self.dlg.setWindowTitle('ADREM tool - 1.0.0')
        # set help
        self.dlg.buttonBox_help.helpRequested.connect(self._show_help)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:# == QFileDialog.rejected:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #return
            self._make_main_view_layer()
            self._show_main_view_layer()
            self._get_boundary()
            self._show_boundary()
        ## if residential
            if self.dlg.filename_industrialShape != "":
                self._industrial_layer()
                self._show_industrial_layer()
            if self.dlg.filename_residentialShape != "":
                self._residential_layer()
                self._show_residential_layer()
           
            self.do_the_math()
            
            if self.dlg.filename_shallow_csv:
                self._process_csv_shallow()
            if self.dlg.filename_deep_csv:
                self._process_csv_deep_soil()
            if self.dlg.filename_aquifer_csv:
                self._process_csv_aquifer()

            self._analysis()
            
            self._mergeNdOutput()

            self.dlg.close()

            

def set_fill_color(layer):
    _props = layer.renderer().symbol().symbolLayer(0).properties()
    #QgsMessageLog.logMessage("{}".format(_props), 'ADREMTOOL', level=Qgis.Info)
    #_props['color'] = '232,113,141,170'

    actual_color = _props['color']
    a = actual_color.split(',')
    a[-1] = '170'
    _props['color'] = ','.join(a)
    layer.renderer().setSymbol(QgsFillSymbol.createSimple(_props))

def reCatLayer(layer):
    categories = QgsCategorizedSymbolRenderer()
    contaminated_sym = QgsFillSymbol.createSimple({'color':'255,0,0,120'})
    clean_sym = QgsFillSymbol.createSimple({'color':'0,255,0,120'})
    cat_cont = QgsRendererCategory('1',contaminated_sym,'contaminated')
    cat_clean = QgsRendererCategory('0',clean_sym, 'clean')

    categories.addCategory(cat_cont)
    categories.addCategory(cat_clean)

    categories.setClassAttribute('isContaminated')

    layer.setRenderer(categories)
